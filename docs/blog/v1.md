---
layout: page
page_title: book title
---

## Building a v1 product

Last year, a couple Directors from a local tutoring group by the name of Emphasis Education approached me regarding some issues they were experiencing with their business operations. Emphasis Education and its tutor employees primarily work with students in the K-12 range as a way to support and enhance students' school curricula. As they looked to the future, they set their eyes on increasing their client base as well as expanding the number of services offered. With this in mind, they sought to position themselves to be able to solve their current bottlenecks.

A main source of the issues that they were facing stemmed from their reliance on text messaging as a primary medium of communication. This was the means by which everyone - the directors, the tutor employees, and the students and their families all discussed everything from important lesson updates to casual conversations. Because of this, there appeared to be a fractured group culture. A user's casual, non-Emphasis Education conversations are in the same space as the Emphasis Education conversations, so it is hard to have a proper separation of concerns. All conversations now appear to have the same level of improtance. This surface-level feeling of disconnect is one thing, but it also presents a very real obstacle. It now beceomes much easier to lose important messages from a tutor in the sea of other communication going on simultaneously in the same space. Now this is affecting a tutor's ability to effectively conduct their sessions. Emphasis Education is now almost competing for a user's attention by conducting their work in this space.

There is also the issue of a bad actor tutor trying to poach clients. Every text message between tutors and students cannot be monitored, so it would be difficult to prevent this if it became an issue. Up until now, Emphasis Education was operating in a tight-knit space where this wasn't really a possibility. This was by no means at the top of the list issues, but the plan of expansion brings in lesser known individuals and the business needs to be protected.

These seemingly small flaws became much larger once the Covid-19 pandemic hit and all interactions moved to virtual and asynchronous. Previously, the problems with text messaging could be overlooked because there was plenty of in-person meetings to supplement tutoring operations. If there were some important breakthroughs or topics that had to be discussed, meetings at coffee shops or local libraries could be quickly scheduled. Now, that could no longer be depended on. The Emphasis Education directors felt like it was harder and harder to be aware of how individual students were doing, and gauging lesson progress became much more difficult. A much more smooth and robust means of a communication between all parties had to be adopted in order to keep providing students with quality education. In-class curricula were also suffering at this time as teachers and administrations had to quickly pivot to a whole new method of teaching.

As an up and coming tutoring group, primarily operating in the Chicago suburbs and acquiring students by word of mouth, they were also looking for ways to differentiate themselves. One way they envisioned that happening was through their brand identity. They wanted an opportunity to showcase what they value and what they can give to students of all kinds.

When we thought about a solution that would address all of these concerns, we came to the idea of creating a proprietary mobile application for the Emphasis Education community.

...But once we came to that place, we saw that we needed to further refine what this app would do, and more importantly, what it would be. What purpose would it serve to the Emphasis users? How heavy would the usage be? Would it supplement the current methods of communication or would it replace them entirely?

When we outlined the bottlenecks that we wanted the app to solve, it became clear that the primary function that this app would serve is communication between all the Emphasis Education members. That is, the directors, the tutors, the students, and the students' families. If nothing else, this app should smoothly facilitate communication between these parties.

On top of that, we decided that it should have some sort of user management that would be hidden by a permissions that only the Directors would have. This would allow them to access User profiles and check their progress and what classes they are taking. This would also allow them to organize users in a family structure. This is because of the younger age of some of the students who are getting tutored. If a student is in the 1st grade, then it is very much likely that their parents would also have a vested interest in their child's progress. By enabling a family structure in how the users are organized, we can allow a "Guardian" type account that could be related to a child.

Lastly, in an effort to establish the principles Emphasis Education stand for, we wanted this app to have a look and feeling of ease and simplicity. The app had very important functional uses, but the experience of using it mattered to us as well. The action of moving from page to page, communicating with tutors, and finding more about the services offered all play a major role in generating trust in Emphasis Education as an entity. The introduction of this app into their process would be a significant change, and making the user experience a key prioroty would ensure the onboarding of this app to go smoothly.

By taking text messaging out of the picture entirely and using only this app to communicate, we would be able to address some key pain points.

It would foster a greater sense of community because there is now a separate space where Emphasis Education related communication would take place. It would not be mixed in with all the other text messaging group chats and such. When a user would open this app, there would be a sense of purpose. By consolidating it all into one location, there is a much more cohesive feel when we think about Emphasis Education. The app would serve as a way to bring all the participants together and provide frictionless discussion. There would be no more risk of losing important information becuase there is only one place where it could be. Having a central location also gave the Directors an opportunity to present themselves how they really wanted to. The app gave them a captive audience, so now they could incorporate their values, mission statement, and who they were as educators into the app experience.

By creating a space that is solely for Emphasis Education, the Directors could also now take a much more involved role in how they wanted educate their students. Students' specific needs could now be met in a very precise manner. If one specifc student struggled to complete their weekly assignments, then an automatic push notification could be scheduled every 3 or 4 days reminding them of any incomplete work. If they learned better with a consistent practice, then daily assignments could be configured in the app. Instead of tasks such as these taking up valuable time of the administrators, they could be programmatically configured.

A convenvient scheduling interface could also be incorporated in the app. Currently, sessions are scheduled and rescheduled with a lot of back and forth between the students, their tutors, and the directors. Creating tooling that could empower clients to meet their own needs gives them a sense of agency in their own learning journey.

Jobs such as these that are currently done manually, but do not need to be, were prime targets to be converted as responsibilities of the app. The idea for this solution was to streamline business operations as well as enable scaling in the near future, so the highly customizable and automatable nature of a mobile application looked very appealing.

## The Stack

Now that we had decided what we wanted the app to do, I had to build it. The first choice that I had to make was regarding the stack that i would use. Making an app could happen in many different ways. There were a lot of frameworks and options out there, so outlining what we wanted to the app to do was helpful in making this decision.

I decided to use [React Native](https://reactnative.dev/) to create the client side of the application. One main reason was because Emphasis Education had clients that used both iOS and Android devices. React Native is a framework and library used for writing both iOS and Android apps using JavaScript. By using Recat Native, I would not have to write two separate apps (one for iOS and one of Android). For the backend, I decided to use [Firebase](https://firebase.google.com/) which is a BAAS (backend-as-a-service) that offered database, authentication, and user management services. With Firebase, I would not need to look to multiple third party services to get everything i need, so that was an easy choice. And lastly, I needed a service to essentially connect the client to the backend. When the app is requesting data from the database, there are a couple ways that connection can happen. I chose to go with [GraphQL](https://graphql.org/) because of its ease of use and growing position in the industry marketplace. These various tools also worked very well together, so I knew it would make building out the client application and the serverside serivces simpler.

### Challenges

The process of building everything -- the client application, the server services, the data schema -- was an experience to say the least. And one that took significantly longer than I thought it would. When this project was initially brought to me, I had a partner to help me make this app. However, due to changes location and employment, he had to drop off the project, leaving just me to take on all of the development and testing. That considerably modified the initial timeline that we had agreed upon with the Emphasis Education directors. Another reason the app took much longer than expected was due to the expanded scope along the way.

In retrospect, the requirement gathering process in the very beginning could have been longer. When we were outlining exactly what features we wanted this app to have, we were very general. "A user management interface" read one bullet point. I would soon learn that that statement by no means accurately describes what I should build. Specific features and behaviors were not strictly defined, so there was uncertainty around when exactly I would be done with a feature. Would this user management interface include a search user feature? What fields on a user would a Director be able to search on? I don't know, and neither do they because we did not say so in the initial product outline. Looking back we were too eager to get started. I saw a shiny new project and couldn't help myself. And it was my first time doing a project as big as this so no obstacle was too big that it couldn't be addressed farther down the line. But that eagerness played a role in our failure to solidify specifications of the app.

Communicating those specifications with the Directors, who in the scenario acted as the product owners, also presented some challenges. I found it difficult at times to communicate the minutae of how the app would behave. I would often times revert to an overly technical explanation of functionality - an language that the layperson might not speak. I would mention screen refresh cycles, cache, and component mounting when talking about I was building the app. These words didn't mean much to them when they were asking broad questions about how they would use certain features. This also contributed to the enlongated timeline of the project. We would agree on a set of functionality in the beginning, but then once that feature was complete, we would find that we had misunderstood what the other had said. Either them, or I, would have made some costly assumption about the app structure, and then that would immediately add to our stradily growing pile of technical debt. The saying "If you can't explain it simply, you don't understand it" rang in my head many times. And here I saw how accurate that statement was. I saw how my own understanding of certain react native aspects were lacking, so I saw that I needed to regularly do another level of research before agreeing to a set of features. This method of communication did improve as time went on, but the inital setbacks had already done considerable damage to our expectations.

### Design choices

One benefit of the project taking 14 months vs the 4 I had foolishly thought was that it allowed for a maturity along the way on my part. I could actually learn along the way and improve my process as I progressed through the features, rather than staying with my existing mindset from the very beginning. Along the way, I could consult experts as to the proper way to structure databases, build React components, and even higher level ideologies such as my view on technical debt.

Perhaps the most important methodology that I picked up along this way was the idea of creating an application using a Schema-first-design. The Schema, on a high level, is the data contract between the client and the server. It defines the shape of the data objects stored, as well as what to expect from all service calls. Having these relationships can be seen as restrictive, but that is kind of the point. The client should know exactly what kind of data is to be expected from the database, and the server should know exactly what the client will be asking for. A Schema-first-design encourage to write the schema before writing any code. Although this would then delay creating components and defining architecture, this time being spent now will get paid back with dividends farther down the line. Establishing this agreement between these two parties then allows the development of each to happen independent of each other. The schema is by no means inflexible, however. If farther down the line we see the need to add a field or two an object, that can still can happen. The schema just requires that both the client and server are aware and agree to this change. Once that happens, then we can go right back to independent development.

I enjoyed this part of the project the most. It allowed me to make high level database architecture decisions. Decisions that I had not been in a positon to make before. I got to try my hand at understanding relationships between objects and how to make those the most efficient. Owning all the pieces to this project kept me from kicking the can down the road. If I said "someone will fix this later", there was no mystery on who that "someone" would be. I was forced to make educated decisions about a domain I had little experience with, so dilligent research was very important. It was a terrific learning experience being accountable to myself. It made me a more deliberate and knowledgeable software engineer.

My understanding of technical debt also evolved throughout the course of this project. Previously, I had a negative view of tech debt. It was the mark of a bad decision or oversight on the part of the developer. Why couldn't they just do it right the first time? Then we wouldn't have to take care of this farther down the road? Didn't they know that by doing things that way, they are just making more work for themselves in the future? Again -- why didn't they just do things the right way?

But, in reality, accruing tech debt is the cost of doing business. In a way it is inevitable. There are obviously best practices that should be employed along the way to reduce the amount of tech debt that is accumulated, but it is very hard to move forward through a project with the mindset of 0 tech debt. My distaste for tech debt came from my overlooking a key aspect in project management -- the fact that projects have deadlines. They don't just exist in vacuums; there are multiple groups of people looking for it and you have an obligation to get the products that were promised to them in a timely manner. If this was a personal project that no one was depending on, then I could take all the time in world to explore all possible avenues. But this is a different situation.

A quote I came across during my time working on this project went like this -- "Were I to await perfection, my book would never get finished." That really stuck with me. The idea of how we view our work, and the expectations that we have for it. How perfection, something we all strive for, can often times get in the way of actually completing our goals. It becomes this unattainable standard and puts us in a position where we cannot even finish the idea that we love so much. I wonder how many ideas perfection has killed.

I carried this idea with me, and it reminded me how everything is a process. Including software development. Our code goes through so many iterations and changes. Constantly becoming something different, something new, something better. And that is beautiful. The joy now lies in the pursuit of perfection, not perfection itself. And I think I like that better. It means that there are always more opportunities to learn, grow, improve. I imagined completing this project, making it perfect -- whatever that means -- and then stopping, staring at my screen. I imagine a feeling of "what now" in that moment. So I would much rather be in a space where I can keep leveling up, finding the next best thing. And in a way, that is what tech debt represents. It is a product of the idea that there can always be improvements to what we do. If we are not in a place where we are satisfied, that is okay. We room to grow.

There is a reason this post is called "building a v1 product." Emphasis on the v1 part. This is the first pass at solving the issues in front of me. It is hard to see that at the end of this phase, this application will be in a position to address each and every problem that might come up in the future. Libraries change, best practices change, our expactations of the product change, I will even change. I began to understand that this product will change in the future to be its best version of itself in that time, and there is beauty in that.

### Methodology
When deciding more of the specifics of certain services included in this app, the "Jobs to be done" framework is what guided me. It describes the idea that the user is looking to "hire" an app, or even specific features of an app, to do a defined job for them. For example, a user would hire their weather app to inform them about that day's forecast. That would be the job that app would perform. By looking at products through this lens, we can be very directed in our understanding of why we want to bring a new product in our day-to-day lives. We can simply ask "what job do I want this app to do for me?" and then evaluate the answer to that question. If it does what we want well, then we download the app or pay for it. If it does not, then we say "no thank you" and go along our merry way.

So this is how I approached the building of this app. When constructing the bahavior of various features, I would ask "what job is this part of the app doing for the user?" Always in the back of my mind I understood that the eventual incorporation of the app into the users' lives would be a disruption. They had their own existing method of communicating and dealing with Emphasis Education, and this app would be something new that they would need to understand and get accustomed to. Going forward, the Directors and I agreed that we would not accomodate multiple platoforms for communication. This app would be the only way to discuss Emphasis related topics. That being said, I wanted to make this transition as smooth as possible. And the best way to do so would be to meet the needs of the users as well as possible. The "Jobs to be done framework" was the perfect way of achieving that goal.

In this v1 of the app, the primary job to be done was to make communicating with all Emphasis Education parties as smooth and reliable as possible. That meant making the messaging interface quick and seamless. It should be clear where in the app the conversations would take place. It should be immediately apparant with whom these communications are taking place. A student is probably not going to be taking just one class with this group. That means multiple tutors, multiple sessions to handle. Multiple assignments and strategies that should be managed. All these aspects of a messaging interface should be very clear to even a first time user of this application. These were all jobs that this app would be hired to do.

But the students would not be the only groups of people that would be using this app. This was an app that is meant to help streamline the business of running the tutoring group as well, so the Directors' needs should also be met. They would be the people who would use this app the most out of anyone, hence the the motivation for building a set of admin-speciifc features. These would help them get a better sense of how their business is running and identify any bottlenecks in the future. A searchable directory of users would help greatly in having an understanding of how their client base is structured. They could easily find a user and then be taken to their profile to see their information and what classes they are enrolled in. It would also be helpful to have a one on one conversation with individual users. The main messaging feature was tightly linked with the classes that are being taken by a student. It would include the tutor as well as interested parties. But a director should also be able to speak privately with any individual if there are some concerns or just to get regular updates on progress. I realized that there is not just one type of communication happening in this space, so I wanted to be able to accomodate conversations of all natures.

These jobs to be done were also not set in stone. I understood that what is expected of this app is subject to change. The business will change in the coming years, so therefore so should the app. But by always asking this question -- "what job is this feature being hired to do?" -- my development process would be aligned with the needs of the users.

This jobs to be done framework also affected how I viewed the apps in my own life. Previously I had seen them as just existing in the ether. They were just there, out there, and I would feel lucky if some of them fit into my life and helped me out in some way. But this way of thinking turned that relationship around. Now, I am looking for my apps to do something for me. I am making a choice to bring them into my life and onto my phone because I need them to do something. Putting my own needs first corrected this perspective. I shouldn't feel lucky if I found an app that is good for me -- apps should exist to meet my needs, and if they don't then I need to find one that does.

### architecture
Through this project, I got the chance to understand how an application's architecture should be structured to accomplish certain goals. Specifically, how the client and the server would be splitting up responsibilites. Basically asking, what should each piece do. The majority of features require particiaption by both parts. Simple UI elements could be handled entirely on the client-side, but the major features that would really make the app what it is require a shared responsibility from both halves. My underatanding of where that line dividing up responsibiltiies evolved through the course of the project.

Initially, I engineered the client to take care of a great deal -- from the push notifications, storing user information, and controlling the overall state of the app. I wanted to keep that all in the client side. I had the view that API calls to the server would be very expensive and would slow down the experience of using the app. I was also not the most comfortable in writing server-side code so I natually shied away from it. I had little experience in handling interactions with the Firebase database and User management system so I tried to do tasks like that as little as possible. So I viewed the server as just responsible to feeding me data when I asked. In the first few months, my server repo was just database reads and writes hooked up to my graphql queries.

But as time went on, I came to realize that it was just too much to have the client handle everything. A lot of the struggle came from the fact that a mobile application can be in a lot of states. It can just be closed and still alive in the background. In the background, it can also get stale and fail to update to changes outside of it, such as when another user would message in a common chat. It could also be in a quit state, such as when you would "swipe up" on it to clear it from the background. How would I handle state updates in that situation. It became difficult to accomodate all these different states of the app and how to best update state. I needed to manage component mounting / unmounting and how that would affect what would get updated in the React Native tree hierarchy. This was affecting the user experience and producing unstable behavior. Now that my architecture design choice was affecting how a user would use the app, I knew that I had to change the way I viewed this client and server relationship.

Upon doing some research and noticing the structure in other codebases, I saw that other developers had a higher view of the server than I did. They relegated a great deal more responsibility there. So much so that their balance was almost the complete opposite as mine. Where I saw the server as just a means to feed the client data and nothing more, they saw the client as more of just an extension of the server. A visual representation of what data is present in the databse at that point in time. I'm not going to lie it was a bit of a blow to my ego that I could view this relationship in the complete opposite as what is done in the industry. But that is what this project is for -- a learning experience.

I will say that once I started viewing my own application in this same way, a lot of things got cleared up. A major piece was how I was handling push notifications. This was something that I was taking care of on the client side. I was trying to listen for new messages across all the chats that a user was a part of, wake up the app if i had to (in the case that is was in the quit state), and then locally trigger a banner. Looking at this structure from this new perspective, I saw how desperately I was avoiding letting the server take on more responsibility. I was jumping through so many hoops when how I should have been writing that feature was in the name itself. Push notification. A notification that is pushed to a device. I knew that to accomplish this, I would have to store more information on the server, such as specific device IDs and the groups that they were a part of. it did take a major rewreite, but as I was going through it, the flow of information came a lot easier. I no longer felt like I was fighting the app structure by trying to fit a square peg in a circle hole. And sure enough, with a little more digging and few more pull requests, the push notification feature made a lot more sense.

This same change in perspective also helped my rewrite of the notification badge feature. This request sought to mainly help the Directors. By nature of these group chats with all the students, they are added to each and every group chat created. Even today, that is a great deal of conversations to keep track of. And this number would only increase as time went on and they expanded to serve more students. They needed a way to see whether there were any unread messages in their conversations, or else they would need to open each and every chat to see if there was anything that they needed to address.

This unread notification badge was something that I was also handling mainly on the client side. But that too became overwhelming when I took into consideration all the different states that the app could be in and how to handle the state across not just one portion of the app, but the entire thing. I found myself writing brittle code that was half-solving the issue at hand. Once again, I looked to the server to solve the shortcomings of the client. I found that this aspect of the app fit nicely in the server once I let it. I had just never considered storing the state of the app on the server. It was a foreign concept to me. But once I started rewrting this behavior, it just made sense. I could store the unread state of a message in the database relatively easily. It was very closely related to the messages themselves, so it was natural to keep this state there as well.

This is just one of the many things I learned about app development that I learned while doing. Reading about coding is fine, and it has its benefits, but wrting code has no equal. I see that this is the best way to learn -- to do, and redo as many times as needed.

### What I learned
The most important part of a project is the beginning. A good foundation goes a long way.
plan plan plan

They understood that the mobile application is still a form of virtual communication, but with their own custom application, they could ensure that they were always involved with the student-related information, and those interactions could happen in their own space. the communication was not mixed with all their other text conversations, so there was a sense of separation of spaces. Branding, user interactions, custom behaviors, this was all up to them now, and they could make specific requests regarding how they wanted the app to function. These are some of the reasons that Emphasis Education went with the custom application route instead of trying to make an existing platform work for them.

In addition, the increased use of text message as the source of communication between all the members of EMphasis Education as a result of the pandemic was a development group admins were not too thrilled about. There were concerns about requiring all members to provide their phone numbers as a primary source of communication. WHen the group was operating in a known community, people were okay with depending on text messages to communicate with their tutors, but there is a future now where a tutor and their student could possibly be strangers,

Only having text messaging as the means of communication could also present a problem with client retention. With the unsupervised nature of text messaging, malicious tutors could poach clients with lower prices or direct them to other tutoring organizations. Though this is unlikely, with the idea of expansion on the horizon, Emphasis is looking to do what

Emphasis Education is a tutoring group for k-12 students that is focused on developing individual relationships as well as personalized curricula to empower each child.

Over the past couple months, they were noticing some issues with their business operations that they were looking to solve as they looked to expand their client-base as well as increase the number of services that they offer.


They were noticing that they were taking care of a lot of business operations manually. These small tasks were adding up over time, and as they were looking to expand and take on more students, the way they were running things was not scalable.

Their current method of communication was through text message. This makes sense when the community of students and tutors are tight-knit. But there will be a time in the future when a student and a tutor will be unknown to each other. Then, it would be not be approproate to require a phone number and mandate that important communication take place in that space.

They also wanted a way to develop their brand identity. They are a relatively small group, so they were looking for a way to distinguich themselves

Once we put all these issues into a pot together and stirred them around, the solution that made the most sense was to create a customized mobile application that would be able to check all of the boxes that they had.

### The stack

I decided to write the mobile application in React Native. Firebase for backend and database. NodeJS Server. Graphql to connect the two

Writing this app was a great learning experience because I got to try a lot of new things and explore new libraries. I really got to create something, and that was a fantastic experience. It really opened my mind up to what it meant to be a software engineer. The only other proper software engineering experience I had was at Amount, and in a work setting, and especially at this age, I only had visibility over a select portion of the apps that we were actively developing on.

It was a very satisfying experience to be able to create something that other people will use. I really enjoyed being additive and adding value with the product that I built.

Building this app also helped me appreciate all the other roles that are involved in the software development process, such as project and product management because I had to play those roles as well. It helped me expand my perspective of what really the product is. I realize how that I had sort of a software ego before this project.